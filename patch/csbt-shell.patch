Index: hbase-shell/src/main/ruby/hbase/hbase.rb
===================================================================
--- hbase-shell/src/main/ruby/hbase/hbase.rb	(revision 26264)
+++ hbase-shell/src/main/ruby/hbase/hbase.rb	(working copy)
@@ -23,6 +23,8 @@
 require 'hbase/table'
 require 'hbase/security'
 require 'hbase/visibility_labels'
+require 'hbase/crosssite_admin'
+require 'hbase/crosssite_table'
 
 module Hbase
   class Hbase
@@ -60,5 +62,14 @@
     def visibility_labels_admin(formatter)
       ::Hbase::VisibilityLabelsAdmin.new(configuration, formatter)
     end
+	
+    def crosssite_admin(formatter)
+      ::Hbase::CrossSiteAdmin.new(configuration, formatter)	
+    end
+	
+     # Create new one each time
+    def crosssite_table(table, formatter)
+      ::Hbase::CrossSiteTable.new(configuration, table, formatter)
+    end
   end
 end
Index: hbase-shell/src/main/ruby/hbase/crosssite_table.rb
===================================================================
--- hbase-shell/src/main/ruby/hbase/crosssite_table.rb	(revision 0)
+++ hbase-shell/src/main/ruby/hbase/crosssite_table.rb	(revision 0)
@@ -0,0 +1,366 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+include Java
+
+# Wrapper for org.apache.hadoop.hbase.client.crosssite.CrossSiteHTable
+module Hbase
+  class CrossSiteTable
+    include HBaseConstants
+    attr_reader :table
+    @@thread_pool = nil
+    
+    def initialize(configuration, table_name, formatter)
+        @table = org.apache.hadoop.hbase.client.crosssite.CrossSiteHTable.new(configuration, table_name)
+        #raise ArgumentError, @table
+      #end
+    end
+    
+     #----------------------------------------------------------------------------------------------
+    # Put a cell 'value' at specified table/row/column
+    def put(row, column, value, timestamp = nil)
+      p = org.apache.hadoop.hbase.client.Put.new(row.to_s.to_java_bytes)
+      family, qualifier = parse_column_name(column)
+      if timestamp
+        p.add(family, qualifier, timestamp, value.to_s.to_java_bytes)
+      else
+        p.add(family, qualifier, value.to_s.to_java_bytes)
+      end
+      @table.put(p)
+    end
+
+    #----------------------------------------------------------------------------------------------
+    # Delete a cell
+    def delete(row, column, timestamp = org.apache.hadoop.hbase.HConstants::LATEST_TIMESTAMP)
+      deleteall(row, column, timestamp)
+    end
+
+    #----------------------------------------------------------------------------------------------
+    # Delete a row
+    def deleteall(row, column = nil, timestamp = org.apache.hadoop.hbase.HConstants::LATEST_TIMESTAMP)
+      d = org.apache.hadoop.hbase.client.Delete.new(row.to_s.to_java_bytes, timestamp)
+      if column
+        family, qualifier = parse_column_name(column)
+        d.deleteColumns(family, qualifier, timestamp)
+      end
+      @table.delete(d)
+    end
+
+    #----------------------------------------------------------------------------------------------
+    # Increment a counter atomically
+    def incr(row, column, value = nil)
+      value ||= 1
+      family, qualifier = parse_column_name(column)
+      @table.incrementColumnValue(row.to_s.to_java_bytes, family, qualifier, value)
+    end
+
+    #----------------------------------------------------------------------------------------------
+    # Count rows in a table
+    def count(interval = 1000, caching_rows = 10)
+      # We can safely set scanner caching with the first key only filter
+      scan = org.apache.hadoop.hbase.client.Scan.new
+      scan.cache_blocks = false
+      scan.caching = caching_rows
+      scan.setFilter(org.apache.hadoop.hbase.filter.FirstKeyOnlyFilter.new)
+
+      # Run the scanner
+      scanner = @table.getScanner(scan)
+      count = 0
+      iter = scanner.iterator
+
+      # Iterate results
+      while iter.hasNext
+        row = iter.next
+        count += 1
+        next unless (block_given? && count % interval == 0)
+        # Allow command modules to visualize counting process
+        yield(count, 
+              org.apache.hadoop.hbase.util.Bytes::toStringBinary(row.getRow))
+      end
+
+      # Return the counter
+      return count
+    end
+
+    #----------------------------------------------------------------------------------------------
+    # Get from table
+    def get(row, *args)
+      get = org.apache.hadoop.hbase.client.Get.new(row.to_s.to_java_bytes)
+      maxlength = -1
+
+      # Normalize args
+      args = args.first if args.first.kind_of?(Hash)
+      if args.kind_of?(String) || args.kind_of?(Array)
+        columns = [ args ].flatten.compact
+        args = { COLUMNS => columns }
+      end
+
+      #
+      # Parse arguments
+      #
+      unless args.kind_of?(Hash)
+        raise ArgumentError, "Failed parse of of #{args.inspect}, #{args.class}"
+      end
+
+      # Get maxlength parameter if passed
+      maxlength = args.delete(MAXLENGTH) if args[MAXLENGTH]
+      filter = args.delete(FILTER) if args[FILTER]
+
+      unless args.empty?
+        columns = args[COLUMN] || args[COLUMNS]
+        if args[VERSIONS]
+          vers = args[VERSIONS]
+        else
+          vers = 1
+        end
+        if columns
+          # Normalize types, convert string to an array of strings
+          columns = [ columns ] if columns.is_a?(String)
+
+          # At this point it is either an array or some unsupported stuff
+          unless columns.kind_of?(Array)
+            raise ArgumentError, "Failed parse column argument type #{args.inspect}, #{args.class}"
+          end
+
+          # Get each column name and add it to the filter
+          columns.each do |column|
+            family, qualifier = parse_column_name(column.to_s)
+            if qualifier
+              get.addColumn(family, qualifier)
+            else
+              get.addFamily(family)
+            end
+          end
+
+          # Additional params
+          get.setMaxVersions(vers)
+          get.setTimeStamp(args[TIMESTAMP]) if args[TIMESTAMP]
+          get.setTimeRange(args[TIMERANGE][0], args[TIMERANGE][1]) if args[TIMERANGE]
+        else
+          # May have passed TIMESTAMP and row only; wants all columns from ts.
+          unless ts = args[TIMESTAMP] || tr = args[TIMERANGE]
+            raise ArgumentError, "Failed parse of #{args.inspect}, #{args.class}"
+          end
+
+          get.setMaxVersions(vers)
+          # Set the timestamp/timerange
+          get.setTimeStamp(ts.to_i) if args[TIMESTAMP]
+          get.setTimeRange(args[TIMERANGE][0], args[TIMERANGE][1]) if args[TIMERANGE]
+        end
+      end
+
+      unless filter.class == String
+        get.setFilter(filter)
+      else
+        get.setFilter(org.apache.hadoop.hbase.filter.ParseFilter.new.parseFilterString(filter))
+      end
+
+      # Call hbase for the results
+      result = @table.get(get)
+      return nil if result.isEmpty
+
+      # Print out results.  Result can be Cell or RowResult.
+      res = {}
+      result.list.each do |kv|
+        family = String.from_java_bytes(kv.getFamily)
+        qualifier = org.apache.hadoop.hbase.util.Bytes::toStringBinary(kv.getQualifier)
+
+        column = "#{family}:#{qualifier}"
+        value = to_string(column, kv, maxlength)
+
+        if block_given?
+          yield(column, value)
+        else
+          res[column] = value
+        end
+      end
+
+      # If block given, we've yielded all the results, otherwise just return them
+      return ((block_given?) ? nil : res)
+    end
+
+    #----------------------------------------------------------------------------------------------
+    # Fetches and decodes a counter value from hbase
+    def get_counter(row, column)
+      family, qualifier = parse_column_name(column.to_s)
+      # Format get request
+      get = org.apache.hadoop.hbase.client.Get.new(row.to_s.to_java_bytes)
+      get.addColumn(family, qualifier)
+      get.setMaxVersions(1)
+
+      # Call hbase
+      result = @table.get(get)
+      return nil if result.isEmpty
+
+      # Fetch cell value
+      cell = result.list[0]
+      org.apache.hadoop.hbase.util.Bytes::toLong(cell.getValue)
+    end
+
+    #----------------------------------------------------------------------------------------------
+    # Scans whole table or a range of keys and returns rows matching specific criterias
+    def scan(args = {})
+      unless args.kind_of?(Hash)
+        raise ArgumentError, "Arguments should be a hash. Failed to parse #{args.inspect}, #{args.class}"
+      end
+
+      limit = args.delete("LIMIT") || -1
+      maxlength = args.delete("MAXLENGTH") || -1
+
+      if args.any?
+        filter = args["FILTER"]
+        startrow = args["STARTROW"] || ''
+        stoprow = args["STOPROW"]
+        timestamp = args["TIMESTAMP"]
+        columns = args["COLUMNS"] || args["COLUMN"] || []
+        cache_blocks = args["CACHE_BLOCKS"] || true
+        cache = args["CACHE"] || 0
+        versions = args["VERSIONS"] || 1
+        timerange = args[TIMERANGE]
+        raw = args["RAW"] || false
+        clusterName = args["CLUSTERNAMES"]
+
+        # Normalize column names
+        columns = [columns] if columns.class == String
+        unless columns.kind_of?(Array)
+          raise ArgumentError.new("COLUMNS must be specified as a String or an Array")
+        end
+        if !clusterName.nil? && !clusterName.kind_of?(Array)
+          raise ArgumentError.new("Clusternames must be specified as an Array")
+        end
+        scan = if stoprow
+          org.apache.hadoop.hbase.client.Scan.new(startrow.to_java_bytes, stoprow.to_java_bytes)
+        else
+          org.apache.hadoop.hbase.client.Scan.new(startrow.to_java_bytes)
+        end
+
+        columns.each do |c| 
+          family, qualifier = parse_column_name(c.to_s)
+          if qualifier
+            scan.addColumn(family, qualifier)
+          else
+            scan.addFamily(family)
+          end
+        end
+
+        unless filter.class == String
+          scan.setFilter(filter)
+        else
+          scan.setFilter(org.apache.hadoop.hbase.filter.ParseFilter.new.parseFilterString(filter))
+        end
+
+        scan.setTimeStamp(timestamp) if timestamp
+        scan.setCacheBlocks(cache_blocks)
+        scan.setCaching(cache) if cache > 0
+        scan.setMaxVersions(versions) if versions > 1
+        scan.setTimeRange(timerange[0], timerange[1]) if timerange
+        scan.setRaw(raw)
+      else
+        scan = org.apache.hadoop.hbase.client.Scan.new
+      end
+
+      # Start the scanner
+      if clusterName.nil?
+      	scanner = @table.getScanner(scan)
+      else 
+        scanner = @table.getScanner(scan, clusterName.to_java(:string))
+      end  
+      count = 0
+      res = {}
+      iter = scanner.iterator
+
+      # Iterate results
+      while iter.hasNext
+        if limit > 0 && count >= limit
+          break
+        end
+
+        row = iter.next
+        key = org.apache.hadoop.hbase.util.Bytes::toStringBinary(row.getRow)
+
+        row.list.each do |kv|
+          family = String.from_java_bytes(kv.getFamily)
+          qualifier = org.apache.hadoop.hbase.util.Bytes::toStringBinary(kv.getQualifier)
+
+          column = "#{family}:#{qualifier}"
+          cell = to_string(column, kv, maxlength)
+
+          if block_given?
+            yield(key, "column=#{column}, #{cell}")
+          else
+            res[key] ||= {}
+            res[key][column] = cell
+          end
+        end
+
+        # One more row processed
+        count += 1
+      end
+
+      return ((block_given?) ? count : res)
+    end
+    
+      #----------------------------------------------------------------------------------------
+    # Helper methods
+
+    # Returns a list of column names in the table
+    def get_all_columns
+      @table.table_descriptor.getFamilies.map do |family|
+        "#{family.getNameAsString}:"
+      end
+    end
+
+    # Checks if current table is one of the 'meta' tables
+    def is_meta_table?
+      tn = @table.table_name
+      org.apache.hadoop.hbase.util.Bytes.equals(tn, org.apache.hadoop.hbase.HConstants::META_TABLE_NAME)
+    end
+
+    # Returns family and (when has it) qualifier for a column name
+    def parse_column_name(column)
+      split = org.apache.hadoop.hbase.KeyValue.parseColumn(column.to_java_bytes)
+      return split[0], (split.length > 1) ? split[1] : nil
+    end
+
+    # Make a String of the passed kv
+    # Intercept cells whose format we know such as the info:regioninfo in .META.
+    def to_string(column, kv, maxlength = -1)
+      if is_meta_table?
+        if column == 'info:regioninfo' or column == 'info:splitA' or column == 'info:splitB'
+          hri = org.apache.hadoop.hbase.util.Writables.getHRegionInfoOrNull(kv.getValue)
+          return "timestamp=%d, value=%s" % [kv.getTimestamp, hri.toString]
+        end
+        if column == 'info:serverstartcode'
+          if kv.getValue.length > 0
+            str_val = org.apache.hadoop.hbase.util.Bytes.toLong(kv.getValue)
+          else
+            str_val = org.apache.hadoop.hbase.util.Bytes.toStringBinary(kv.getValue)
+          end
+          return "timestamp=%d, value=%s" % [kv.getTimestamp, str_val]
+        end
+      end
+
+      if kv.isDelete
+        val = "timestamp=#{kv.getTimestamp}, type=#{org.apache.hadoop.hbase.KeyValue::Type::codeToType(kv.getType)}"
+      else
+        val = "timestamp=#{kv.getTimestamp}, value=#{org.apache.hadoop.hbase.util.Bytes::toStringBinary(kv.getValue)}"
+      end
+      (maxlength != -1) ? val[0, maxlength] : val
+    end
+  end
+end
Index: hbase-shell/src/main/ruby/hbase/crosssite_admin.rb
===================================================================
--- hbase-shell/src/main/ruby/hbase/crosssite_admin.rb	(revision 0)
+++ hbase-shell/src/main/ruby/hbase/crosssite_admin.rb	(revision 0)
@@ -0,0 +1,322 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+include Java
+java_import org.apache.hadoop.hbase.util.Pair
+java_import org.apache.hadoop.hbase.util.RegionSplitter
+java_import org.apache.hadoop.hbase.crosssite.CrossSiteUtil
+
+# Wrapper for org.apache.hadoop.hbase.client.HBaseAdmin
+
+module Hbase
+  class CrossSiteAdmin
+    include HBaseConstants
+     def initialize(configuration, formatter)
+      @crosssiteadmin = org.apache.hadoop.hbase.client.crosssite.CrossSiteHBaseAdmin.new(configuration)
+      @admin = org.apache.hadoop.hbase.client.HBaseAdmin.new(configuration)
+      @conf = configuration
+      @formatter = formatter
+     end
+    
+    #--------------------------------------------------------------------------------
+    # adds a cluster to the CSBT
+    def addCluster(args={})
+      raise(ArgumentError, "Arguments cannot be empty") if args.empty?
+      name = args[NAME] if args[NAME]
+      raise(ArgumentError, "Name of the cluster should be specified") if name.empty?
+      address = args[ADDRESS] if args[ADDRESS]
+      raise(ArgumentError, "Address of the cluster should be specified") if address.empty?
+      @crosssiteadmin.addCluster(name.to_java.to_s, address.to_java.to_s)
+    end
+    
+    #-----------------------------------------------------------------------------------
+    # delete a cluster from the CSBT
+    def deleteCluster(cluster)
+      raise(ArgumentError, "Clustername cannot be null") if cluster.nil?
+      raise(ArgumentError, "Clsutername cannot be empty") if cluster.empty?
+      @crosssiteadmin.deleteCluster(cluster.to_java.to_s)
+    end
+    #-----------------------------------------------------------------------------------
+    #adds a peer cluster to an existing cluster
+    def addPeer(cluster, args={})
+      raise(ArgumentError, "Clustername cannot be empty") if cluster.to_s.empty?
+      raise(ArgumentError, "Arguments cannot be empty") if args.empty?
+      name = args[NAME] if args[NAME]
+      raise(ArgumentError, "Name of the peer should be specified") if name.empty?
+      address = args[ADDRESS] if args[ADDRESS]
+      raise(ArgumentError, "Address of the peer should be specified") if address.empty?
+      peerCluster = Pair.new(name, address)
+      @crosssiteadmin.addPeer(cluster, peerCluster)
+    end
+    
+    #----------------------------------------------------------------------------------------------
+    # deletes a hierarchy from the csbt node
+    def deleteHierarchy(parent)
+      raise(ArgumentError, "Parent name cannot be null") if parent.nil?
+      raise(ArgumentError, "Parent name cannot be empty") if parent.empty?
+      @crosssiteadmin.deleteHierarchy(parent.to_java.to_s)
+    end
+    #----------------------------------------------------------------------------------------------
+    # lists all the child clusters in the hierarchy
+    def listChildClusters(parent)
+      raise(ArgumentError, "Parent name cannot be null") if parent.nil?
+      raise(ArgumentError, "Parent name cannot be empty") if parent.empty?
+      @crosssiteadmin.listChildClusters(parent.to_java.to_s)
+    end
+    #----------------------------------------------------------------------------------------------
+    # lists all the descendant clusters in the hierarchy
+    def listDescendantClusters(parent)
+      raise(ArgumentError, "Parent name cannot be null") if parent.nil?
+      raise(ArgumentError, "Parent name cannot be empty") if parent.empty?
+      @crosssiteadmin.listDescendantClusters(parent.to_java.to_s)
+    end
+    #----------------------------------------------------------------------------------------------
+    # Returns a list of tables in hbase
+    def list(regex = ".*")
+      begin
+        # Use the old listTables API first for compatibility with older servers
+        tabledescriptors = @crosssiteadmin.listTables(regex)
+        if tabledescriptors != nil
+          tabledescriptors.map { |t| t.getNameAsString }
+        end
+      rescue => e
+        # listTables failed, try the new unprivileged getTableNames API if the cause was
+        # an AccessDeniedException
+        if e.cause.kind_of? org.apache.hadoop.ipc.RemoteException and e.cause.unwrapRemoteException().kind_of? org.apache.hadoop.hbase.security.AccessDeniedException
+          @crosssiteadmin.getTableNames(regex)
+        else
+          # Not an access control failure, re-raise
+          raise e
+        end
+      end
+    end
+    
+    #----------------------------------------------------------------------------------------------
+    # Returns a list of clusters in hbase
+    def listCluster()
+      @crosssiteadmin.listClusters()
+    end
+    
+    #---------------------------------------------------------------------------------------------
+    # returns a list of peers in hbase
+    def listPeers(cluster)
+      @crosssiteadmin.listPeers(cluster.to_s.to_java)
+    end
+    #----------------------------------------------------------------------------------------------
+    
+    #----------------------------------------------------------------------------------------------
+    # adds hierarchy
+    def addHierarchy(cluster, *args)
+      raise(ArgumentError, "Cluster name cannot be null") if cluster.nil?
+      raise(ArgumentError, "Children should be string array") unless args.kind_of?(Array)
+      if args.kind_of?(Array)
+        children = [ args ].flatten.compact
+      end
+      begin
+        @crosssiteadmin.addHierarchy(cluster, children.to_java(:string))
+      end
+    end
+    
+    #-----------------------------------------------------------------------------------------------
+    # deletes peers from the cluster
+    def deletePeers(cluster, args={})
+      raise(ArgumentError, "Cluster name cannot be null") if cluster.nil?
+      peers = args[PEERS] if args[PEERS]
+      if peers != nil
+        raise(ArgumentError, "Peers should be string array") unless peers.kind_of?(Array)
+        peers = [peers].flatten.compact
+        @crosssiteadmin.deletePeers(cluster, peers.to_java(:string))
+      else 
+        @crosssiteadmin.deletePeers(cluster)	
+      end
+    end
+    #----------------------------------------------------------------------------------------------     
+    # Creates a table
+    def create(table_name, *args)
+      # Fail if table name is not a string
+      raise(ArgumentError, "Table name must be of type String") unless table_name.kind_of?(String)
+
+      # Flatten params array
+      args = args.flatten.compact
+
+      # Fail if no column families defined
+      raise(ArgumentError, "Table must have at least one column family") if args.empty?
+      # Start defining the table
+      htd = org.apache.hadoop.hbase.HTableDescriptor.new(table_name)
+      splits = nil
+      clusterLocator = nil
+      # Args are either columns or splits, add them to the table definition
+      # TODO: add table options support
+      args.each do |arg|
+        unless arg.kind_of?(String) || arg.kind_of?(Hash)
+          raise(ArgumentError, "#{arg.class} of #{arg.inspect} is not of Hash or String type")
+        end
+        if arg.kind_of?(String)
+          # the arg is a string, default action is to add a column to the table
+          htd.addFamily(hcd(arg, htd))
+        else
+          # arg is a hash.  4 possibilities:
+          if (arg.has_key?(SPLITS) or arg.has_key?(SPLITS_FILE))
+            if arg.has_key?(SPLITS_FILE)
+              unless File.exist?(arg[SPLITS_FILE])
+                raise(ArgumentError, "Splits file #{arg[SPLITS_FILE]} doesn't exist")
+              end
+              arg[SPLITS] = []
+              File.foreach(arg[SPLITS_FILE]) do |line|
+                arg[SPLITS].push(line.strip())
+              end
+            end
+
+            splits = Java::byte[][arg[SPLITS].size].new
+            idx = 0
+            arg[SPLITS].each do |split|
+              splits[idx] = split.to_java_bytes
+              idx = idx + 1
+            end
+          elsif (arg.has_key?(NUMREGIONS) or arg.has_key?(SPLITALGO))
+            # (1) deprecated region pre-split API
+            raise(ArgumentError, "Column family configuration should be specified in a separate clause") if arg.has_key?(NAME)
+            raise(ArgumentError, "Number of regions must be specified") unless arg.has_key?(NUMREGIONS)
+            raise(ArgumentError, "Split algorithm must be specified") unless arg.has_key?(SPLITALGO)
+            raise(ArgumentError, "Number of regions must be greater than 1") unless arg[NUMREGIONS] > 1
+            num_regions = arg[NUMREGIONS]
+            split_algo = RegionSplitter.newSplitAlgoInstance(@conf, arg[SPLITALGO])
+            splits = split_algo.split(JInteger.valueOf(num_regions))
+          elsif (method = arg.delete(METHOD))
+            # (2) table_att modification
+            raise(ArgumentError, "table_att is currently the only supported method") unless method == 'table_att'
+            raise(ArgumentError, "NUMREGIONS & SPLITALGO must both be specified") unless arg.has_key?(NUMREGIONS) == arg.has_key?(split_algo)
+            htd.setMaxFileSize(JLong.valueOf(arg[MAX_FILESIZE])) if arg[MAX_FILESIZE]
+            htd.setReadOnly(JBoolean.valueOf(arg[READONLY])) if arg[READONLY]
+            htd.setMemStoreFlushSize(JLong.valueOf(arg[MEMSTORE_FLUSHSIZE])) if arg[MEMSTORE_FLUSHSIZE]
+            htd.setDeferredLogFlush(JBoolean.valueOf(arg[DEFERRED_LOG_FLUSH])) if arg[DEFERRED_LOG_FLUSH]
+            htd.setValue(COMPRESSION_COMPACT, arg[COMPRESSION_COMPACT]) if arg[COMPRESSION_COMPACT]
+            if arg[NUMREGIONS]
+              raise(ArgumentError, "Number of regions must be greater than 1") unless arg[NUMREGIONS] > 1
+              num_regions = arg[NUMREGIONS]
+              split_algo = RegionSplitter.newSplitAlgoInstance(@conf, arg[SPLITALGO])
+              splits = split_algo.split(JInteger.valueOf(num_regions))
+            end
+            if arg[CONFIGURATION]
+              raise(ArgumentError, "#{CONFIGURATION} must be a Hash type") unless arg.kind_of?(Hash)
+              for k,v in arg[CONFIGURATION]
+                v = v.to_s unless v.nil?
+                htd.setValue(k, v)
+              end
+            end
+          elsif (arg.has_key?(LOCATOR))
+            clusterLocator = CrossSiteUtil.instantiateClusterLocator(@conf, arg[LOCATOR])
+            raise(ArgumentError, "Clsuter locator must be specified") if clusterLocator.nil?
+            if (arg.has_key?(LOCATOR_ARGS))
+             clusterLocatorArgs = arg[LOCATOR_ARGS]
+             # TODO : Check the arg specification for the PrefixClusterLocator
+             clusterLocator.validateArguments(clusterLocatorArgs.to_java(:string))
+            end
+          #end  
+          else
+            # (3) column family spec
+            descriptor = hcd(arg, htd)
+            htd.setValue(COMPRESSION_COMPACT, arg[COMPRESSION_COMPACT]) if arg[COMPRESSION_COMPACT]
+            htd.addFamily(hcd(arg, htd))
+          end
+        end
+      end
+
+      if splits.nil?
+        # Perform the create table call
+        @crosssiteadmin.createTable(htd)
+      else
+        # Perform the create table call
+        if clusterLocator.nil?
+          @crosssiteadmin.createTable(htd, splits)
+        else
+          @crosssiteadmin.createTable(htd, splits, clusterLocator, true)
+        end
+      end
+    end
+    #--------------------------------------------------------------------------------------------------------
+    #----------------------------------------------------------------------------------------------
+    # Return a new HColumnDescriptor made of passed args
+    def hcd(arg, htd)
+      # String arg, single parameter constructor
+      return org.apache.hadoop.hbase.HColumnDescriptor.new(arg) if arg.kind_of?(String)
+
+      raise(ArgumentError, "Column family #{arg} must have a name") unless name = arg[NAME]
+
+      family = htd.getFamily(name.to_java_bytes)
+      # create it if it's a new family
+      family ||= org.apache.hadoop.hbase.HColumnDescriptor.new(name.to_java_bytes)
+
+      family.setBlockCacheEnabled(JBoolean.valueOf(arg[org.apache.hadoop.hbase.HColumnDescriptor::BLOCKCACHE])) if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::BLOCKCACHE)
+      family.setScope(JInteger.valueOf(arg[org.apache.hadoop.hbase.HColumnDescriptor::REPLICATION_SCOPE])) if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::REPLICATION_SCOPE)
+      family.setInMemory(JBoolean.valueOf(arg[org.apache.hadoop.hbase.HColumnDescriptor::IN_MEMORY])) if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::IN_MEMORY)
+      family.setTimeToLive(JInteger.valueOf(arg[org.apache.hadoop.hbase.HColumnDescriptor::TTL])) if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::TTL)
+      family.setDataBlockEncoding(org.apache.hadoop.hbase.io.encoding.DataBlockEncoding.valueOf(arg[org.apache.hadoop.hbase.HColumnDescriptor::DATA_BLOCK_ENCODING])) if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::DATA_BLOCK_ENCODING)
+      family.setEncodeOnDisk(JBoolean.valueOf(arg[org.apache.hadoop.hbase.HColumnDescriptor::ENCODE_ON_DISK])) if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::ENCODE_ON_DISK)
+      family.setBlocksize(JInteger.valueOf(arg[org.apache.hadoop.hbase.HColumnDescriptor::BLOCKSIZE])) if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::BLOCKSIZE)
+      family.setMaxVersions(JInteger.valueOf(arg[org.apache.hadoop.hbase.HColumnDescriptor::VERSIONS])) if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::VERSIONS)
+      family.setMinVersions(JInteger.valueOf(arg[org.apache.hadoop.hbase.HColumnDescriptor::MIN_VERSIONS])) if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::MIN_VERSIONS)
+      family.setKeepDeletedCells(JBoolean.valueOf(arg[org.apache.hadoop.hbase.HColumnDescriptor::KEEP_DELETED_CELLS])) if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::KEEP_DELETED_CELLS)
+      if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::BLOOMFILTER)
+        bloomtype = arg[org.apache.hadoop.hbase.HColumnDescriptor::BLOOMFILTER].upcase
+        unless org.apache.hadoop.hbase.regionserver.StoreFile::BloomType.constants.include?(bloomtype)      
+          raise(ArgumentError, "BloomFilter type #{bloomtype} is not supported. Use one of " + org.apache.hadoop.hbase.regionserver.StoreFile::BloomType.constants.join(" ")) 
+        else 
+          family.setBloomFilterType(org.apache.hadoop.hbase.regionserver.StoreFile::BloomType.valueOf(bloomtype))
+        end
+      end
+      if arg.include?(org.apache.hadoop.hbase.HColumnDescriptor::COMPRESSION)
+        compression = arg[org.apache.hadoop.hbase.HColumnDescriptor::COMPRESSION].upcase
+        unless org.apache.hadoop.hbase.io.hfile.Compression::Algorithm.constants.include?(compression)      
+          raise(ArgumentError, "Compression #{compression} is not supported. Use one of " + org.apache.hadoop.hbase.io.hfile.Compression::Algorithm.constants.join(" ")) 
+        else 
+          family.setCompressionType(org.apache.hadoop.hbase.io.hfile.Compression::Algorithm.valueOf(compression))
+        end
+      end
+
+      if arg[CONFIGURATION]
+        raise(ArgumentError, "#{CONFIGURATION} must be a Hash type") unless arg.kind_of?(Hash)
+        for k,v in arg[CONFIGURATION]
+          v = v.to_s unless v.nil?
+          family.setValue(k, v)
+        end
+      end
+      return family
+    end
+    #----------------------------------------------------------------------------------------------     
+    # Disables a table
+    def disable(table_name)
+      #Do we need to do some other checks here
+      @crosssiteadmin.disableTable(table_name)
+    end
+
+    #----------------------------------------------------------------------------------------------     
+    # Enables a table
+    def enable(table_name)
+      #Do we need to do some other checks here
+      @crosssiteadmin.enableTable(table_name)
+    end
+
+    #-------------------------------------------------------------------------------------------------
+    #Deletes a table
+    def deleteTable(table_name)
+      #Do we need to do some other checks here
+      @crosssiteadmin.deleteTable(table_name)
+    end
+  end
+end
Index: hbase-shell/src/main/ruby/hbase.rb
===================================================================
--- hbase-shell/src/main/ruby/hbase.rb	(revision 26264)
+++ hbase-shell/src/main/ruby/hbase.rb	(working copy)
@@ -61,6 +61,11 @@
   ATTRIBUTES="ATTRIBUTES"
   VISIBILITY="VISIBILITY"
   AUTHORIZATIONS = "AUTHORIZATIONS"
+  ADDRESS = "ADDRESS"
+  PEERS = "PEERS"
+  LOCATOR = "LOCATOR"
+  LOCATOR_ARGS = "LOCATOR_ARGS"
+  CLUSTERNAMES = "CLUSTERNAMES"
 
   # Load constants from hbase java API
   def self.promote_constants(constants)
@@ -83,3 +88,5 @@
 require 'hbase/replication_admin'
 require 'hbase/security'
 require 'hbase/visibility_labels'
+require 'hbase/crosssite_admin'
+require 'hbase/crosssite_table'
Index: hbase-shell/src/main/ruby/shell/commands/list_crosssitepeers.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/list_crosssitepeers.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/list_crosssitepeers.rb	(revision 0)
@@ -0,0 +1,41 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+module Shell
+  module Commands
+    class ListCrosssitepeers< Command
+      def help
+        return <<-EOF
+List all peer clusters of the current cluster. Optional regular expression parameter could
+be used to filter the output. Examples:
+
+  hbase> list_crosssitepeers 'cluster1'
+EOF
+      end
+
+      def command(cluster)
+        now = Time.now
+        formatter.header([ "CLUSTER", "CLUSTER_KEY" ])
+
+        list = crosssite_admin.listPeers(cluster)
+        list.each do |cluster|
+          formatter.row([ cluster.getName(), cluster.getAddress() ])
+        end
+        formatter.footer(now, list.size)
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/enable_crosssitetable.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/enable_crosssitetable.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/enable_crosssitetable.rb	(revision 0)
@@ -0,0 +1,34 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+module Shell
+  module Commands
+    class EnableCrosssitetable < Command
+      def help
+        return <<-EOF
+Enables a cross-site table
+
+  hbase> enable_crosssitetable 't1'
+EOF
+      end
+      def command(table)
+        format_simple_command do
+          crosssite_admin.enable(table)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/crosssite_delete.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/crosssite_delete.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/crosssite_delete.rb	(revision 0)
@@ -0,0 +1,43 @@
+#
+# Copyright 2010 The Apache Software Foundation
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+module Shell
+  module Commands
+    class CrosssiteDelete < Command
+      def help
+        return <<-EOF
+Put a delete cell value at specified table/row/column and optionally
+timestamp coordinates.  Deletes must match the deleted cell's
+coordinates exactly.  When scanning, a delete cell suppresses older
+versions. To delete a cell from  't1' at row 'r1' under column 'c1'
+marked with the time 'ts1', do:
+
+  hbase> crosssite_delete 't1', 'r1', 'c1', ts1
+EOF
+      end
+
+      def command(table, row, column, timestamp = org.apache.hadoop.hbase.HConstants::LATEST_TIMESTAMP)
+        format_simple_command do
+          crosssite_table(table).delete(row, column, timestamp)
+        end
+      end
+    end
+  end
+end
Index: hbase-shell/src/main/ruby/shell/commands/crosssite_get.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/crosssite_get.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/crosssite_get.rb	(revision 0)
@@ -0,0 +1,55 @@
+#
+# Copyright 2010 The Apache Software Foundation
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+module Shell
+  module Commands
+    class CrosssiteGet < Command
+      def help
+        return <<-EOF
+Get row or cell contents; pass table name, row, and optionally
+a dictionary of column(s), timestamp, timerange and versions. Examples:
+
+  hbase> crosssite_get 't1', 'r1'
+  hbase> crosssite_get 't1', 'r1', {TIMERANGE => [ts1, ts2]}
+  hbase> crosssite_get 't1', 'r1', {COLUMN => 'c1'}
+  hbase> crosssite_get 't1', 'r1', {COLUMN => ['c1', 'c2', 'c3']}
+  hbase> crosssite_get 't1', 'r1', {COLUMN => 'c1', TIMESTAMP => ts1}
+  hbase> crosssite_get 't1', 'r1', {COLUMN => 'c1', TIMERANGE => [ts1, ts2], VERSIONS => 4}
+  hbase> crosssite_get 't1', 'r1', {COLUMN => 'c1', TIMESTAMP => ts1, VERSIONS => 4}
+  hbase> crosssite_get 't1', 'r1', {FILTER => "ValueFilter(=, 'binary:abc')"}
+  hbase> crosssite_get 't1', 'r1', 'c1'
+  hbase> crosssite_get 't1', 'r1', 'c1', 'c2'
+  hbase> crosssite_get 't1', 'r1', ['c1', 'c2']
+EOF
+      end
+
+      def command(table, row, *args)
+        now = Time.now
+        formatter.header(["COLUMN", "CELL"])
+
+        crosssite_table(table).get(row, *args) do |column, value|
+          formatter.row([ column, value ])
+        end
+
+        formatter.footer(now)
+      end
+    end
+  end
+end
Index: hbase-shell/src/main/ruby/shell/commands/list_childclusters.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/list_childclusters.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/list_childclusters.rb	(revision 0)
@@ -0,0 +1,41 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+module Shell
+  module Commands
+    class ListChildclusters< Command
+      def help
+        return <<-EOF
+List the names of all the child clusters in the hierarchy. Examples:
+
+  hbase> list_childclusters 'cluster1'
+
+EOF
+      end
+
+      def command(cluster)
+        now = Time.now
+        formatter.header([ "CLUSTER" ])
+
+        list = crosssite_admin.listChildClusters(cluster)
+        list.each do |childCluster|
+          formatter.row([ childCluster ])
+        end
+        formatter.footer(now, list.size)
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/disable_crosssitetable.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/disable_crosssitetable.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/disable_crosssitetable.rb	(revision 0)
@@ -0,0 +1,34 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+module Shell
+  module Commands
+    class DisableCrosssitetable < Command
+      def help
+        return <<-EOF
+Disables a cross-site table
+
+  hbase> disable_crosssitetable 't1'
+EOF
+      end
+      def command(table)
+        format_simple_command do
+          crosssite_admin.disable(table)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/list_crosssitetable.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/list_crosssitetable.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/list_crosssitetable.rb	(revision 0)
@@ -0,0 +1,51 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+module Shell
+  module Commands
+    class ListCrosssitetable< Command
+      def help
+        return <<-EOF
+List all cross-site tables in hbase. Optional regular expression parameter could
+be used to filter the output. Examples:
+
+  hbase> list_crosssitetable
+  hbase> list_crosssitetable 'abc.*'
+EOF
+      end
+
+      def command(regex = ".*")
+        now = Time.now
+        formatter.header([ "TABLE" ])
+
+        regex = /#{regex}/ unless regex.is_a?(Regexp)
+        list = crosssite_admin.list
+        if list != nil
+        	list.grep(regex)
+        	list.each do |table|
+          		formatter.row([ table ])
+        	end
+
+        	formatter.footer(now, list.size)
+        else 
+        	formatter.footer(now, 0)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/crosssite_scan.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/crosssite_scan.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/crosssite_scan.rb	(revision 0)
@@ -0,0 +1,74 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+module Shell
+  module Commands
+    class CrosssiteScan < Command
+      def help
+        return <<-EOF
+Scan a table; pass table name and optionally a dictionary of scanner
+specifications.  Scanner specifications may include one or more of:
+TIMERANGE, FILTER, LIMIT, STARTROW, STOPROW, TIMESTAMP, MAXLENGTH,
+or COLUMNS, CACHE
+
+If no columns are specified, all columns will be scanned.
+To scan all members of a column family, leave the qualifier empty as in
+'col_family:'.
+
+The filter can be specified in two ways:
+1. Using a filterString - more information on this is available in the
+Filter Language document attached to the HBASE-4176 JIRA
+2. Using the entire package name of the filter.
+
+Some examples:
+
+  hbase> crosssite_scan '.META.'
+  hbase> crosssite_scan '.META.', {COLUMNS => 'info:regioninfo'}
+  hbase> crosssite_scan 't1', {COLUMNS => ['c1', 'c2'], LIMIT => 10, STARTROW => 'xyz'}
+  hbase> crosssite_scan 't1', {COLUMNS => ['c1', 'c2'], LIMIT => 10, STARTROW => 'xyz', CLUSTERNAMES => ['cluster1', 'cluster2']}
+  hbase> crosssite_scan 't1', {COLUMNS => 'c1', TIMERANGE => [1303668804, 1303668904]}
+  hbase> crosssite_scan 't1', {FILTER => "(PrefixFilter ('row2') AND (QualifierFilter (>=, 'binary:xyz'))) AND (TimestampsFilter ( 123, 456))"}
+  hbase> crosssite_scan 't1', {FILTER => org.apache.hadoop.hbase.filter.ColumnPaginationFilter.new(1, 0)}
+
+For experts, there is an additional option -- CACHE_BLOCKS -- which
+switches block caching for the scanner on (true) or off (false).  By
+default it is enabled.  Examples:
+
+  hbase> crosssite_scan 't1', {COLUMNS => ['c1', 'c2'], CACHE_BLOCKS => false}
+
+Also for experts, there is an advanced option -- RAW -- which instructs the
+scanner to return all cells (including delete markers and uncollected deleted
+cells). This option cannot be combined with requesting specific COLUMNS.
+Disabled by default.  Example:
+
+  hbase> crosssite_scan 't1', {RAW => true, VERSIONS => 10}
+EOF
+      end
+
+      def command(table, args = {})
+        now = Time.now
+        formatter.header(["ROW", "COLUMN+CELL"])
+
+        count = crosssite_table(table).scan(args) do |row, cells|
+          formatter.row([ row, cells ])
+        end
+
+        formatter.footer(now, count)
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/add_hierarchy.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/add_hierarchy.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/add_hierarchy.rb	(revision 0)
@@ -0,0 +1,35 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+module Shell
+  module Commands
+    class AddHierarchy < Command
+      def help
+        return <<-EOF
+Adds a hierarchy to the cluster znode under the CSBT
+  hbase> add_hierarchy 'cluster1',['A','B']
+
+EOF
+      end
+
+      def command(cluster, *args)
+        format_simple_command do
+          crosssite_admin.addHierarchy(cluster, *args)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/list_descendantclusters.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/list_descendantclusters.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/list_descendantclusters.rb	(revision 0)
@@ -0,0 +1,41 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+module Shell
+  module Commands
+    class ListDescendantclusters< Command
+      def help
+        return <<-EOF
+List the names of all the descendant clusters in the hierarchy. Examples:
+
+  hbase> list_descendantclusters 'cluster1'
+
+EOF
+      end
+
+      def command(cluster)
+        now = Time.now
+        formatter.header([ "CLUSTER" ])
+
+        list = crosssite_admin.listDescendantClusters(cluster)
+        list.each do |descendantCluster|
+          formatter.row([ descendantCluster ])
+        end
+        formatter.footer(now, list.size)
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/add_cluster.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/add_cluster.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/add_cluster.rb	(revision 0)
@@ -0,0 +1,37 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+module Shell
+  module Commands
+    class AddCluster < Command
+      def help
+        return <<-EOF
+Adds a cluster to the cluster znode under the CSBT
+Specifying duplicates in peers would consider only unique entries
+  hbase> add_cluster NAME=>'cluster1', ADDRESS=>'0.0.0.0:2181:/hbase'
+
+EOF
+      end
+
+      def command(*args)
+        format_simple_command do
+          crosssite_admin.addCluster(*args)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/crosssite_deletepeers.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/crosssite_deletepeers.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/crosssite_deletepeers.rb	(revision 0)
@@ -0,0 +1,37 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+module Shell
+  module Commands
+    class CrosssiteDeletepeers < Command
+      def help
+        return <<-EOF
+Deletes a set of peers associated with the cluster or the entire set of peers associated
+with the cluster when the PEERS are not specified
+Specifying duplicates in peers would consider only unique entries
+  hbase> crosssite_deletepeers 'cluster1',PEERS=>['peercluster1','peercluster2']
+
+EOF
+      end
+
+      def command(cluster, *args)
+        format_simple_command do
+          crosssite_admin.deletePeers(cluster, *args)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/delete_hierarchy.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/delete_hierarchy.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/delete_hierarchy.rb	(revision 0)
@@ -0,0 +1,37 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+module Shell
+  module Commands
+    class DeleteHierarchy < Command
+      def help
+        return <<-EOF
+Deletes an hierarchy under the CSBT
+Specifying duplicates in peers would consider only unique entries
+  hbase> delete_hierarchy 'parent'
+
+EOF
+      end
+
+      def command(parent)
+        format_simple_command do
+          crosssite_admin.deleteHierarchy(parent)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/crosssite_addpeer.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/crosssite_addpeer.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/crosssite_addpeer.rb	(revision 0)
@@ -0,0 +1,36 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+module Shell
+  module Commands
+    class CrosssiteAddpeer < Command
+      def help
+        return <<-EOF
+Adds a peer cluster to another cluster under the CSBT
+Specifying duplicates in peers would consider only unique entries
+  hbase> crosssite_addpeer 'cluster1',NAME=>'cluster2',ADDRESS=>'1.1.1.1:2181:/hbase'
+
+EOF
+      end
+
+      def command(cluster, *args)
+        format_simple_command do
+          crosssite_admin.addPeer(cluster, *args)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/delete_cluster.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/delete_cluster.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/delete_cluster.rb	(revision 0)
@@ -0,0 +1,36 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+module Shell
+  module Commands
+    class DeleteCluster < Command
+      def help
+        return <<-EOF
+Deletes a cluster to the cluster znode under the CSBT
+  hbase> delete_cluster 'cluster1'
+
+EOF
+      end
+
+      def command(clusterName)
+        format_simple_command do
+          crosssite_admin.deleteCluster(clusterName)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/crosssite_put.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/crosssite_put.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/crosssite_put.rb	(revision 0)
@@ -0,0 +1,39 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+module Shell
+  module Commands
+    class CrosssitePut < Command
+      def help
+        return <<-EOF
+Put a cell 'value' at specified table/row/column and optionally
+timestamp coordinates.  To put a cell value into table 't1' at
+row 'r1' under column 'c1' marked with the time 'ts1', do:
+
+  hbase> crosssite_put 't1', 'r1', 'c1', 'value', ts1
+EOF
+      end
+
+      def command(table, row, column, value, timestamp = nil)
+        format_simple_command do
+          crosssite_table(table).put(row, column, value, timestamp)
+        end
+      end
+    end
+  end
+end
Index: hbase-shell/src/main/ruby/shell/commands/delete_crosssitetable.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/delete_crosssitetable.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/delete_crosssitetable.rb	(revision 0)
@@ -0,0 +1,34 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+module Shell
+  module Commands
+    class DeleteCrosssitetable < Command
+      def help
+        return <<-EOF
+Deletes a cross-site table
+
+  hbase> delete_crosssitetable 't1'
+EOF
+      end
+      def command(table)
+        format_simple_command do
+          crosssite_admin.deleteTable(table)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands/create_crosssitetable.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/create_crosssitetable.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/create_crosssitetable.rb	(revision 0)
@@ -0,0 +1,45 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+module Shell
+  module Commands
+    class CreateCrosssitetable < Command
+      def help
+        return <<-EOF
+Creates a cross-site table
+
+  hbase> create_crosssitetable 't1', {NAME => 'f1', VERSIONS => 5}
+  hbase> create_crosssitetable 't1', {NAME => 'f1'}, {NAME => 'f2'}, {NAME => 'f3'}
+  hbase> # The above in shorthand would be the following:
+  hbase> create_crosssitetable 't1', 'f1', 'f2', 'f3'
+  hbase> create_crosssitetable 't1', {NAME => 'f1', VERSIONS => 1, TTL => 2592000, BLOCKCACHE => true}
+  hbase> create_crosssitetable 't1', 'f1', {SPLITS => ['10', '20', '30', '40']}
+  hbase> create_crosssitetable 't1', 'f1', {SPLITS_FILE => 'splits.txt'}
+  hbase> # Optionally pre-split the table into NUMREGIONS, using
+  hbase> # SPLITALGO ("HexStringSplit", "UniformSplit" or classname)
+  hbase> create_crosssitetable 't1', 'f1', {NUMREGIONS => 15, SPLITALGO => 'HexStringSplit'}
+  hbase> create_crosssitetable 't1', 'f1', {SPLITS => ['10', '20']}, {LOCATOR => 'org.apache.hadoop.hbase.crosssite.locator.SubstringClusterLocator', LOCATOR_ARGS=>['5','7']}
+
+EOF
+      end
+      def command(table, *args)
+        format_simple_command do
+          crosssite_admin.create(table, *args)
+        end
+      end
+    end
+  end
+end
Index: hbase-shell/src/main/ruby/shell/commands/list_cluster.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands/list_cluster.rb	(revision 0)
+++ hbase-shell/src/main/ruby/shell/commands/list_cluster.rb	(revision 0)
@@ -0,0 +1,42 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+module Shell
+  module Commands
+    class ListCluster< Command
+      def help
+        return <<-EOF
+List all clusters in hbase. Optional regular expression parameter could
+be used to filter the output. Examples:
+
+  hbase> list_cluster
+
+EOF
+      end
+
+      def command()
+        now = Time.now
+        formatter.header([ "CLUSTER" ])
+
+        list = crosssite_admin.listCluster()
+        list.each do |cluster|
+          formatter.row([ cluster.getName() ])
+        end
+        formatter.footer(now, list.size)
+      end
+    end
+  end
+end
\ No newline at end of file
Index: hbase-shell/src/main/ruby/shell/commands.rb
===================================================================
--- hbase-shell/src/main/ruby/shell/commands.rb	(revision 26264)
+++ hbase-shell/src/main/ruby/shell/commands.rb	(working copy)
@@ -65,6 +65,14 @@
       def visibility_labels_admin
         @shell.hbase_visibility_labels_admin
       end
+	  
+      def crosssite_admin
+        @shell.hbase_crosssite_admin
+      end
+      
+      def crosssite_table(name)
+        @shell.hbase_crosssite_table(name)
+      end
 
       #----------------------------------------------------------------------
 
Index: hbase-shell/src/main/ruby/shell.rb
===================================================================
--- hbase-shell/src/main/ruby/shell.rb	(revision 26264)
+++ hbase-shell/src/main/ruby/shell.rb	(working copy)
@@ -93,6 +93,14 @@
     def hbase_visibility_labels_admin
       @hbase_visibility_labels_admin ||= hbase.visibility_labels_admin(formatter)
     end
+	
+    def hbase_crosssite_admin
+      @hbase_crosssite_admin ||= hbase.crosssite_admin(formatter)
+    end
+    
+    def hbase_crosssite_table(name)
+      hbase.crosssite_table(name, formatter)
+    end
 
     def export_commands(where)
       ::Shell.commands.keys.each do |cmd|
@@ -365,3 +373,31 @@
     set_visibility
   ]
 )
+
+Shell.load_command_group(
+  'crosssitetable',
+  :full_name => 'CROSS SITE TABLE TOOLS',
+  :comment => "NOTE: Above commands are only applicable if running the CSBT",
+  :commands => %w[
+    add_cluster
+    delete_cluster
+    crosssite_addpeer
+    crosssite_deletepeers
+    create_crosssitetable
+    delete_crosssitetable
+    enable_crosssitetable
+    disable_crosssitetable
+    list_crosssitetable
+    list_cluster
+    list_crosssitepeers
+    add_hierarchy
+    delete_hierarchy
+    list_childclusters
+    list_descendantclusters
+    crosssite_put
+    crosssite_scan
+    crosssite_delete
+    crosssite_get
+  ]
+)
+
